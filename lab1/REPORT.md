# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Черемисинов М.Л.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|    4.11      |    4          |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
 
В императивных языках данные можно хранить и как в языке Пролог, однако наоборот, например, использовать массивы с индексацией и доступом к любому элементу уже не получится.

Из cхожих особенностей списки в прологе, на мой взгляд, очень напоминают односвязные списки из императивных языков: текущий элемент (голова) + ссылка на следующий (хвост). Однако, по крайней мере в SWI-Prolog списки может содержать элементы разных типов, что в этом случае делает его более похожим конкретно на списки из Python или кортежи из C++.


## Задание 1.1: Предикат обработки списка

`count1(List,X, N), count2(List, X, N)` - подсчёт числа вхождений элемента X в список List. Результат заносится в N.

Примеры использования:
```prolog
?- count1([1,2,3,1],1,X).
X = 2 .
?- count2([1,2,3,4,5,6],7,X).
X = 0 .
```

Реализация:
```prolog
%без стандартных предикатов
count1([], _, 0).
count1([X|T], X, N):-
	count1(T, X, N1),
	N is N1 + 1.
count1([_|T], X, N):-
	count1(T, X, N).

%со стандартными предикатами
count2([], _, 0).
count2([X|Y], X, N):-
	permute1(Y, T),
	count2(T, X, N1),
	N is N1 + 1.
count2([_|Y], X, N):-
	permute1(Y, T),
	count2(T, X, N1),
	N is N1.
```

`count1` - если элемент в голове - считаем его количество в хвосте и прибавляем к результату 1, если не в голове - считаем в хвосте без прибавления 1.

`count2` - то же, что и `count1`, только с добавлением перестановок.

## Задание 1.2: Предикат обработки числового списка

`max1(List, X), max2(List, X)` - нахождение максимального элемента в списке List. Результат заносится в X.

Примеры использования:
```prolog
?- max1([7,1,8,9,0,4],X).
X = 9 .

?- max2([1,0,-5,-7,1,-8],X).
X = 1 .
```

Реализация:
```prolog
%без стандартных предикатов
help_max1(X1, X2, Z):-
	(X1 >= X2, Z is X1);
	(X1 < X2, Z is X2).

max1([X], X).
max1([X|Y], N):-
	max1(Y, N1),
	help_max1(X, N1, Z),
	N = Z.

%со стандартными предикатами
help_max2([H|T], N):-
	N >= H,
	help_max2(T, N).
help_max2([], _).

max2(X, N):-
	remove1(N, X, Y),
	help_max2(Y, N).
```

`max1` - считаем максимум для хвоста и сравниваем его с головой при помощи `help_max1`.

`max2` - удаляем по одному элементу из списка, проверяем при помощи `help_max2`, не меньше ли он какого-либо элемента из оставшегося списка.

## Задание 2: Реляционное представление данных

Для себя из преимуществ реляционного представления смог выделить то, что эта модель сама по себе достаточно простая, легкая для понимания человеком.
Из недостатков - могут появится трудности при разработке в достаточно простых местах.

Во втором представлении много повторяющейся информации: на 1 ученика нужно хранить 6 правил, в каждом из которых 2 поля из 4 совпадают. При `N` предметах, для 1 учащегося в общем хранится `4N` полей. Более экономно было бы использовать, например, представление grade(группа, студент, \[предмет1, оценка\], \[предмет2, оценка\]), тогда при `N` предметах на 1 человека тратится `2+2N` полей. 

Вариант 1.
1. `task1()` - выводит таблицу вида `группа: [студенты] avg: средний балл`. Создается список уникальных групп. По этому списку ищутся уникальные студенты и высчитываются оценки.
2. `task2()` - выводит таблицу вида `предмет: [студенты]`. Создает список уникальных предметов, для каждого предмета выводит фамилию студента, который его не сдал.
3. `task3()` - выводит таблицу вида `группа: количество несдавших`. Создает список уникальных групп. По каждой группе ищутся студенты, у которых 2 за экзамен, повторения студентов (если 2 по нескольким предметам) удаляются, выводится их количество.

## Выводы

Складывается впечатление, что решать повседневные задачи на прологе - не самая лучшая идея, уходит много времени и сил, в особенности на такие задания, как второе. На мой взгляд, пролог отлично подходит для решения логических задач и задач, связанных с множествами, в которых  много различных условий. Остальные же задания, как, к примеру, второе, связанные с парсингом текста и обработкой каких-либо данных, зачастую проще решаются при помощи императивных языков программирования.

Если говорить про саму лабораторную работу, то с первым заданием проблем не возникло, описал 2 простых предиката по обработке списков, а вот во втором столкнулся с некоторыми проблемами. По последним коммитам можно увидеть, что сначала делал для каждого предмета прописывал предикаты вручную, только через некоторое время смог найти более красивое решение через 2 `findall`'а.
